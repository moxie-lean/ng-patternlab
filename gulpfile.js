'use strict';

//
// imports
//
var gulp = require('gulp');
var gutil = require('gulp-util');
var templateCache = require('gulp-angular-templatecache');
var fs = require('fs');
var glob = require('glob');
var path = require('path');
var htmlEscape = require('html-escape');
var _ = require('lodash');

//
// constants
//
var CONFIG_FILE = '../../config/patterns.json';
var COMMON_HEADER = 'AUTO-GENERATED BY GULP';
var COMMON_HEADER_JS = '/*** ' + COMMON_HEADER + ' ***/';
var COMMON_HEADER_HTML = '<!-- ' + COMMON_HEADER + ' -->';
var TEMPLATE_CACHE_HEADER = COMMON_HEADER_JS + '\n\n' + 'angular.module("lnPatterns").run(["$templateCache", function($templateCache) {';
var PATTERNS_TEMPLATE = 'templates/patterns/template';
var PATTERNS_TEMPLATE_PAGE = PATTERNS_TEMPLATE + '.html';
var ENCODING = 'utf8';
var HEADER_REGEX = /\/\*\*\*.*\*\*\*\//;
var COMPONENT_REGEX = /{COMPONENT}[\s\S]*{END_COMPONENT}/m;

//
// global variables
//
var appConfig = null;
var enabledTemplates = [];

//
// tasks
//
gulp.task('lnPatternsLoadConfig', function(cb){
  //load application config file
  try {
    appConfig = require(CONFIG_FILE);
  }
  catch(e) {
    gutil.log('Application config file not found. All components will be included.');
  }

  cb();
});

gulp.task('lnPatternsComponents', ['lnPatternsLoadConfig'], function(cb){
  var atoms = '';
  var molecules = '';
  var organisms = '';
  var templates = '';

  //read tpl files
  var componentsTpl = fs.readFileSync('./lib/ngComponents.tpl', ENCODING);
  componentsTpl = componentsTpl.replace(HEADER_REGEX, COMMON_HEADER_JS);

  var patternsTpl = fs.readFileSync('./lib/' + PATTERNS_TEMPLATE + '.tpl', ENCODING);
  patternsTpl = patternsTpl.replace(HEADER_REGEX, COMMON_HEADER_HTML);

  //get component html from tpl
  var componentHtml = COMPONENT_REGEX.exec(patternsTpl)[0];
  componentHtml = componentHtml.replace('{COMPONENT}', '');
  componentHtml = componentHtml.replace('{END_COMPONENT}', '');
  patternsTpl = patternsTpl.replace(COMPONENT_REGEX, '');

  var include = function(file, collection) {
    var splitted = file.split('/');
    var folder = splitted.slice(2, -1).join('/');
    var filename = splitted.pop().replace('.js', '');
    var compEnabled = true;
    var compConfig = {};

    //check if the component is enabled in the application config file
    if (appConfig) {
      compConfig = _.find(appConfig.enabledComponents, {'component': folder, 'generic': true});

      if (!compConfig)
        compEnabled = false;
    }

    if (compEnabled) {
      //get component metadata
      var metadata = require('./lib/' + folder + '/metadata.json');

      //include import string into the corresponding atomic type
      var reqStr = "require('./" + folder + "/" + filename + "');\n";
      
      if (collection == 'atoms')
        atoms += reqStr;
      else if (collection == 'molecules')
        molecules += reqStr;
      else if (collection == 'organisms')
        organisms += reqStr;
      else
        templates += reqStr;

      if (filename.indexOf('directive') >= 0) {
        //instantiate component html and include into patterns tpl
        patternsTpl += componentHtml
          .replace(/{COMPONENT_NAME}/g, metadata.name)
          .replace(/{COMPONENT_DESCRIPTION}/g, metadata.description)
          .replace(/{COMPONENT_PARAMS}/g, JSON.stringify(metadata.params))
          .replace(/{COMPONENT_EXAMPLE}/g, htmlEscape(fs.readFileSync('./lib/' + folder + '/example.html', ENCODING)));

        //add component path to the enabled templates list
        enabledTemplates.push('./lib/' + folder + '/template.html');
      }
    }
  };

  glob.sync('./lib/atoms/**/*.js').forEach(function(file) { include(file, 'atoms'); });
  glob.sync('./lib/molecules/**/*.js').forEach(function(file) { include(file, 'molecules'); });
  glob.sync('./lib/organisms/**/*.js').forEach(function(file) { include(file, 'organisms'); });
  glob.sync('./lib/templates/**/*.js').forEach(function(file) { include(file, 'templates'); });

  //instantiate components imports and include them into components tpl
  componentsTpl = componentsTpl.replace('{ATOMS}', atoms);
  componentsTpl = componentsTpl.replace('{MOLECULES}', molecules);
  componentsTpl = componentsTpl.replace('{ORGANISMS}', organisms);
  componentsTpl = componentsTpl.replace('{TEMPLATES}', templates);

  //generate components imports into ngComponents.js
  fs.writeFile('./lib/ngComponents.js', componentsTpl, function(){
    var filePath = './lib/' + PATTERNS_TEMPLATE_PAGE;

    if (!appConfig || appConfig.generatePatternsPage) {
      enabledTemplates.push(filePath);

      //generate patterns page
      fs.writeFile(filePath, patternsTpl, cb);
    }
    else {
      //delete patterns page if exists
      try {
        fs.unlinkSync(filePath);
      }
      catch(e) {}

      cb();
    }
  });
});

gulp.task('lnPatternsTemplates', ['lnPatternsComponents'], function() {
  return gulp.src(enabledTemplates, {base: path.resolve(__dirname + '/lib/')})
    //generate templates cache into ngTemplates.js
    .pipe(templateCache('ngTemplates.js', {
      transformUrl: function(url) {
        if (url.indexOf(PATTERNS_TEMPLATE_PAGE) >= 0)
          return PATTERNS_TEMPLATE_PAGE;
        else
          return 'lnPatterns' + url;
      },
      templateHeader: TEMPLATE_CACHE_HEADER
    }))
    //write ngTemplates.js into lib folder
    .pipe(gulp.dest('./lib'));
});

gulp.task('lnPatterns', ['lnPatternsTemplates']);