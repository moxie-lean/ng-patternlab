'use strict';

//
// imports
//
var gulp = require('gulp');
var templateCache = require('gulp-angular-templatecache');
var fs = require('fs');
var glob = require('glob');
var htmlEscape = require('html-escape');

//
// constants
//
var COMMON_HEADER = 'AUTO-GENERATED BY GULP';
var COMMON_HEADER_JS = '/*** ' + COMMON_HEADER + ' ***/';
var COMMON_HEADER_HTML = '<!-- ' + COMMON_HEADER + ' -->';
var TEMPLATE_CACHE_HEADER = COMMON_HEADER_JS + '\n\n' + 'angular.module("lnPatterns").run(["$templateCache", function($templateCache) {';
var PATTERNS_TEMPLATE = 'templates/patterns/template';
var ENCODING = 'utf8';
var HEADER_REGEX = /\/\*\*\*.*\*\*\*\//;
var COMPONENT_REGEX = /{COMPONENT}[\s\S]*{END_COMPONENT}/m;

//
// tasks
//
gulp.task('lnPatternsComponents', function(cb){
  var atoms = '';
  var molecules = '';
  var organisms = '';
  var templates = '';

  var componentsTpl = fs.readFileSync('./lib/ngComponents.tpl', ENCODING);
  componentsTpl = componentsTpl.replace(HEADER_REGEX, COMMON_HEADER_JS);

  var patternsTpl = fs.readFileSync('./lib/' + PATTERNS_TEMPLATE + '.tpl', ENCODING);
  patternsTpl = patternsTpl.replace(HEADER_REGEX, COMMON_HEADER_HTML);

  var componentHtml = COMPONENT_REGEX.exec(patternsTpl)[0];
  componentHtml = componentHtml.replace('{COMPONENT}', '');
  componentHtml = componentHtml.replace('{END_COMPONENT}', '');
  patternsTpl = patternsTpl.replace(COMPONENT_REGEX, '');

  var include = function(file, collection) {
    var splitted = file.split('/');
    var folder = splitted.slice(2, -1).join('/');
    var filename = splitted.pop().replace('.js', '');
    var reqStr = "require('./" + folder + "/" + filename + "');\n";
    var metadata = require('./lib/' + folder + '/metadata.json');

    if (collection == 'atoms')
      atoms += reqStr;
    else if (collection == 'molecules')
      molecules += reqStr;
    else if (collection == 'organisms')
      organisms += reqStr;
    else
      templates += reqStr;

    if (filename.indexOf('directive') >= 0) {
      patternsTpl += componentHtml
        .replace(/{COMPONENT_NAME}/g, metadata.name)
        .replace(/{COMPONENT_DESCRIPTION}/g, metadata.description)
        .replace(/{COMPONENT_PARAMS}/g, JSON.stringify(metadata.params))
        .replace(/{COMPONENT_EXAMPLE}/g, htmlEscape(fs.readFileSync('./lib/' + folder + '/example.html', ENCODING)));
    }
  };

  glob.sync('./lib/atoms/**/*.js').forEach(function(file) { include(file, 'atoms'); });
  glob.sync('./lib/molecules/**/*.js').forEach(function(file) { include(file, 'molecules'); });
  glob.sync('./lib/organisms/**/*.js').forEach(function(file) { include(file, 'organisms'); });
  glob.sync('./lib/templates/**/*.js').forEach(function(file) { include(file, 'templates'); });

  componentsTpl = componentsTpl.replace('{ATOMS}', atoms);
  componentsTpl = componentsTpl.replace('{MOLECULES}', molecules);
  componentsTpl = componentsTpl.replace('{ORGANISMS}', organisms);
  componentsTpl = componentsTpl.replace('{TEMPLATES}', templates);

  fs.writeFile('./lib/ngComponents.js', componentsTpl, function(){
    fs.writeFile('./lib/' + PATTERNS_TEMPLATE + '.html', patternsTpl, cb);
  });
});

gulp.task('lnPatternsTemplates', ['lnPatternsComponents'], function() {
  return gulp.src('./lib/**/template.html')
    .pipe(templateCache('ngTemplates.js', {
      transformUrl: function(url) {
        if (url.indexOf(PATTERNS_TEMPLATE + '.html') >= 0)
          return url;
        else
          return 'lnPatterns/' + url;
      },
      templateHeader: TEMPLATE_CACHE_HEADER
    }))
    .pipe(gulp.dest('./lib'));
});

gulp.task('lnPatterns', ['lnPatternsTemplates']);